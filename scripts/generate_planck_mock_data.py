"""
Generate mock Planck 2018 CMB power spectrum data

This script creates synthetic TT/TE/EE power spectra that mimic the Planck 2018
observations, including:
- Acoustic peak structure at ℓ ~ 220, 540, 800, ...
- Silk damping at high-ℓ
- Realistic error bars from cosmic variance + instrumental noise

The mock data is used for testing QFD vacuum refraction predictions.

For production analysis, replace with actual Planck Legacy Archive data:
https://pla.esac.esa.int/pla/
"""

import numpy as np
import pandas as pd
import os

# Planck 2018 best-fit parameters
H0 = 67.4          # km/s/Mpc
Omega_M = 0.315
Omega_Lambda = 0.685
T_CMB = 2.72548    # K

# Sound horizon at recombination (Mpc, comoving)
r_s = 144.39  # From Planck 2018

# Comoving distance to last scattering (z~1090)
# Using same calculation as cmb_power_spectrum.py
C_LIGHT = 2.99792458e8  # m/s
z_CMB = 1090.0

def E(z, Omega_M, Omega_Lambda):
    """Hubble function E(z) = H(z)/H0"""
    return np.sqrt(Omega_M * (1 + z)**3 + Omega_Lambda)

def comoving_distance(z, H0, Omega_M, Omega_Lambda):
    """Comoving distance to redshift z"""
    D_H = (C_LIGHT / 1000.0) / H0
    z_grid = np.linspace(0, z, 1000)
    E_z = E(z_grid, Omega_M, Omega_Lambda)
    D_C = D_H * np.trapz(1.0 / E_z, z_grid)
    return D_C

D_M = comoving_distance(z_CMB, H0, Omega_M, Omega_Lambda)
print(f"D_M(z={z_CMB}) = {D_M:.1f} Mpc (comoving)")

# First acoustic peak position
ell_1 = np.pi * D_M / r_s
print(f"First acoustic peak: ℓ_1 = π D_M / r_s = {ell_1:.1f}")

# Multipole range for Planck
ell_min = 2
ell_max = 2500
ell = np.arange(ell_min, ell_max + 1)

def acoustic_oscillations(ell, ell_1):
    """
    Simplified acoustic oscillation structure.

    Peaks at ℓ ~ n × ℓ_1 / 3 for n = 1, 2, 3, ...
    (Factor of 3 accounts for compression/rarefaction pattern)
    """
    # Phase of oscillation
    phase = 3 * np.pi * ell / ell_1

    # Envelope: rises at low-ℓ, peaks around ℓ~1000, then Silk damping
    envelope = (ell / 100.0) ** 0.5 * np.exp(-((ell - 1000) / 1500) ** 2)

    # Oscillatory part
    oscillation = 1.0 + 0.5 * np.cos(phase)

    return envelope * oscillation

def C_ell_TT_model(ell):
    """
    Mock TT power spectrum (temperature autocorrelation).

    Realistic amplitude ~6000 μK² at first peak.
    """
    baseline = 3000.0  # μK²
    C_TT = baseline * acoustic_oscillations(ell, ell_1)

    # Sachs-Wolfe plateau at low-ℓ
    SW_plateau = 1000.0 * np.exp(-ell / 20.0)
    C_TT = C_TT + SW_plateau

    return C_TT

def C_ell_TE_model(ell):
    """
    Mock TE power spectrum (temperature-E-mode cross-correlation).

    Has both positive and negative values due to phase relationships.
    Amplitude ~120 μK² at first peak.
    """
    baseline = 100.0  # μK²

    # Different phase than TT (90° shift creates negative correlation at certain ℓ)
    phase = 3 * np.pi * ell / ell_1 + np.pi / 2
    envelope = (ell / 100.0) ** 0.5 * np.exp(-((ell - 800) / 1200) ** 2)
    oscillation = np.sin(phase)

    C_TE = baseline * envelope * oscillation

    return C_TE

def C_ell_EE_model(ell):
    """
    Mock EE power spectrum (E-mode autocorrelation).

    Peaks at ℓ ~ 1000, amplitude ~40 μK² at first peak.
    Weaker than TT because polarization is generated by Thomson scattering.
    """
    baseline = 20.0  # μK²

    phase = 3 * np.pi * ell / ell_1
    envelope = (ell / 150.0) ** 1.0 * np.exp(-((ell - 1000) / 1000) ** 2)
    oscillation = 1.0 + 0.6 * np.cos(phase + np.pi / 4)

    C_EE = baseline * envelope * oscillation

    return C_EE

def cosmic_variance_error(ell, C_ell, f_sky=0.57):
    """
    Cosmic variance uncertainty.

    σ_CV = sqrt(2 / ((2ℓ+1) f_sky)) × C_ℓ

    f_sky ~ 0.57 for Planck (after masking)
    """
    sigma_CV = np.sqrt(2.0 / ((2 * ell + 1) * f_sky)) * np.abs(C_ell)
    return sigma_CV

def instrumental_noise(ell, sensitivity_muK_arcmin=1.0):
    """
    Instrumental noise contribution.

    σ_inst ~ (θ_beam / θ_pixel)² for white noise

    Simplified: increases with ℓ due to beam smoothing.
    """
    # Beam FWHM ~ 5 arcmin for Planck
    theta_beam_arcmin = 5.0
    theta_beam_rad = theta_beam_arcmin / 60.0 * np.pi / 180.0

    # Beam window function: exp(-ℓ² σ_beam²)
    sigma_beam = theta_beam_rad / np.sqrt(8 * np.log(2))
    W_beam = np.exp(-ell * (ell + 1) * sigma_beam ** 2)

    # Noise increases as beam suppresses signal
    sigma_inst = sensitivity_muK_arcmin * (1.0 / W_beam - 1.0) ** 0.5
    sigma_inst = np.where(W_beam > 0.1, sigma_inst, np.nan)  # Unreliable at high-ℓ

    return sigma_inst

# Generate power spectra
print("\n" + "=" * 70)
print("Generating Mock Planck 2018 Power Spectra")
print("=" * 70)

C_TT = C_ell_TT_model(ell)
C_TE = C_ell_TE_model(ell)
C_EE = C_ell_EE_model(ell)

# Error bars
sigma_TT_CV = cosmic_variance_error(ell, C_TT)
sigma_TE_CV = cosmic_variance_error(ell, C_TE)
sigma_EE_CV = cosmic_variance_error(ell, C_EE)

sigma_TT_inst = instrumental_noise(ell, sensitivity_muK_arcmin=1.0)
sigma_TE_inst = instrumental_noise(ell, sensitivity_muK_arcmin=1.5)
sigma_EE_inst = instrumental_noise(ell, sensitivity_muK_arcmin=2.0)

# Total error (add in quadrature)
sigma_TT = np.sqrt(sigma_TT_CV ** 2 + sigma_TT_inst ** 2)
sigma_TE = np.sqrt(sigma_TE_CV ** 2 + sigma_TE_inst ** 2)
sigma_EE = np.sqrt(sigma_EE_CV ** 2 + sigma_EE_inst ** 2)

# Fill NaN values with large errors (effectively excludes these points)
sigma_TT = np.where(np.isfinite(sigma_TT), sigma_TT, 1e10)
sigma_TE = np.where(np.isfinite(sigma_TE), sigma_TE, 1e10)
sigma_EE = np.where(np.isfinite(sigma_EE), sigma_EE, 1e10)

# Add realistic noise
np.random.seed(42)  # Reproducible
C_TT_obs = C_TT + np.random.normal(0, sigma_TT)
C_TE_obs = C_TE + np.random.normal(0, sigma_TE)
C_EE_obs = C_EE + np.random.normal(0, sigma_EE)

# Statistics
print(f"\n[TT Power Spectrum]")
print(f"  Range: ℓ = {ell_min} to {ell_max}")
print(f"  Peak amplitude: {C_TT.max():.1f} μK²")
print(f"  First peak at: ℓ = {ell[np.argmax(C_TT[:400])]}")
print(f"  Mean error: {sigma_TT[ell < 1000].mean():.1f} μK²")

print(f"\n[TE Power Spectrum]")
print(f"  Amplitude range: [{C_TE.min():.1f}, {C_TE.max():.1f}] μK²")
print(f"  First peak at: ℓ = {ell[np.argmax(np.abs(C_TE[:400]))]}")
print(f"  Mean error: {sigma_TE[ell < 1000].mean():.1f} μK²")

print(f"\n[EE Power Spectrum]")
print(f"  Peak amplitude: {C_EE.max():.1f} μK²")
print(f"  First peak at: ℓ = {ell[np.argmax(C_EE[:400])]}")
print(f"  Mean error: {sigma_EE[ell < 1000].mean():.1f} μK²")

# Create DataFrame
df = pd.DataFrame({
    'ell': ell,
    'C_ell_TT_LCDM': C_TT,
    'C_ell_TT_obs': C_TT_obs,
    'sigma_TT': sigma_TT,
    'C_ell_TE_LCDM': C_TE,
    'C_ell_TE_obs': C_TE_obs,
    'sigma_TE': sigma_TE,
    'C_ell_EE_LCDM': C_EE,
    'C_ell_EE_obs': C_EE_obs,
    'sigma_EE': sigma_EE
})

# Save to data directory
output_dir = '/home/tracy/development/QFD_SpectralGap/data/raw'
os.makedirs(output_dir, exist_ok=True)

output_file = os.path.join(output_dir, 'planck_2018_power_spectra_mock.csv')
df.to_csv(output_file, index=False)

print(f"\n✓ Saved to: {output_file}")
print(f"  Total rows: {len(df)}")
print(f"  Columns: {list(df.columns)}")

print("\n" + "=" * 70)
print("Mock data generation complete")
print("=" * 70)
print("\nNote: This is synthetic data for testing QFD predictions.")
print("For publication, replace with actual Planck Legacy Archive data:")
print("  https://pla.esac.esa.int/pla/")
