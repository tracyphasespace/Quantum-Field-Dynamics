<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>QFD: Corrected Vortex Flow</title>
    <style>
        :root { --bg: #050505; --panel: rgba(20, 20, 30, 0.9); --text: #ccc; --accent: #44aaff; --warn: #ffaa00; }
        body { margin: 0; background: var(--bg); overflow: hidden; font-family: 'Segoe UI', sans-serif; color: var(--text); user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: grab; }
        canvas:active { cursor: grabbing; }
        
        #ui-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 10px; align-items: center;
            z-index: 10;
        }

        .button-row {
            display: flex; gap: 10px; padding: 10px;
            background: var(--panel); border-radius: 30px; backdrop-filter: blur(5px);
            border: 1px solid #333;
        }

        #ui-polarization { display: none; border-color: var(--warn); }
        #ui-polarization.visible { display: flex; animation: fadeIn 0.3s ease; }
        
        button {
            background: transparent; border: 1px solid #555; color: #fff;
            padding: 8px 16px; border-radius: 20px; cursor: pointer;
            font-size: 0.8rem; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap;
        }
        button:hover { background: #333; border-color: #888; }
        button.active { background: var(--accent); border-color: var(--accent); color: #000; font-weight: bold; }
        #ui-polarization button.active { background: var(--warn); border-color: var(--warn); color: #000; }

        #info { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        h1 { margin: 0; font-size: 1.1rem; color: #fff; border-left: 3px solid var(--accent); padding-left: 10px;}
        p { margin: 5px 0 0 14px; font-size: 0.8rem; opacity: 0.7; }
        .instructions { font-size: 0.75rem; color: #666; margin-top: 5px; margin-left: 14px; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div id="info">
    <h1>Cl(3,3) Topology</h1>
    <p id="status-text">Relative Scale Schematic</p>
    <div class="instructions">Left Click to Rotate &bull; Scroll to Zoom</div>
</div>

<div id="ui-container">
    <div class="button-row">
        <button id="btn-schematic" class="active">Relative Scale</button>
        <button id="btn-nuc">Nucleus</button>
        <button id="btn-elec">Electron</button>
        <button id="btn-phot">Photon</button>
    </div>
    <div class="button-row" id="ui-polarization">
        <button id="btn-pol-tor">Toroidal Spin</button>
        <button id="btn-pol-bal" class="active">Balanced</button>
        <button id="btn-pol-pol">Poloidal Spin</button>
    </div>
</div>

<canvas id="cv"></canvas>

<script>
(function() {
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status-text');
    const polUI = document.getElementById('ui-polarization');

    // --- STATE ---
    let activeMode = 'schematic'; 
    let autoRotate = true; 
    
    const STATE = {
        width: 0, height: 0, time: 0,
        camDist: 1000, camOrbit: 0, camTilt: 0.3,
        camTarget: { x: 0, y: 0, z: 0 },
        scaleNuc: 10, scaleElec: 100, scalePhot: 100,
        opacityNuc: 1, opacityElec: 1, opacityPhot: 1,
        vTor: 1.0, vPol: 1.0,
        phaseTor: 0, phasePol: 0
    };

    const TARGET = {
        camDist: 1000,
        scaleNuc: 10, scaleElec: 100, scalePhot: 100,
        opacityNuc: 1, opacityElec: 1, opacityPhot: 1,
        vTor: 1.0, vPol: 1.0
    };

    // --- INTERACTION ---
    function setActive(mode) {
        activeMode = mode;
        document.querySelectorAll('.button-row:first-child button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + mode).classList.add('active');
        
        TARGET.opacityNuc = 0; TARGET.opacityElec = 0; TARGET.opacityPhot = 0;
        
        if(mode === 'phot') {
            polUI.classList.add('visible');
            statusText.innerText = "Photon: Toroidal Flux Tube (Adjust Polarization below)";
        } else {
            polUI.classList.remove('visible');
        }

        if(mode === 'schematic') {
            statusText.innerText = "Relative Scale: Nucleus (Dot), Electron (Sphere), Photon (Ring)";
            TARGET.scaleNuc = 5; TARGET.scaleElec = 60; TARGET.scalePhot = 300; 
            TARGET.opacityNuc = 1; TARGET.opacityElec = 1; TARGET.opacityPhot = 1;
            TARGET.camDist = 800;
        } 
        else if(mode === 'nuc') {
            statusText.innerText = "Nucleus: Resonating Source (4x Speed)";
            TARGET.scaleNuc = 240; 
            TARGET.opacityNuc = 1;
            TARGET.camDist = 600;
        }
        else if(mode === 'elec') {
            statusText.innerText = "Electron: Hill's Vortex (Red Core Up, Blue Shell Down)";
            TARGET.scaleElec = 280; 
            TARGET.opacityElec = 1;
            TARGET.camDist = 700;
        }
        else if(mode === 'phot') {
            TARGET.scalePhot = 280; 
            TARGET.opacityPhot = 1;
            TARGET.camDist = 700;
        }
    }

    function setPolarization(type) {
        document.querySelectorAll('#ui-polarization button').forEach(b => b.classList.remove('active'));
        if(type === 'tor') {
            document.getElementById('btn-pol-tor').classList.add('active');
            TARGET.vTor = 3.0; TARGET.vPol = 0.2; 
        } else if(type === 'bal') {
            document.getElementById('btn-pol-bal').classList.add('active');
            TARGET.vTor = 1.0; TARGET.vPol = 1.0; 
        } else if(type === 'pol') {
            document.getElementById('btn-pol-pol').classList.add('active');
            TARGET.vTor = 0.2; TARGET.vPol = 3.0; 
        }
    }

    ['schematic', 'nuc', 'elec', 'phot'].forEach(id => { document.getElementById('btn-' + id).onclick = () => setActive(id); });
    document.getElementById('btn-pol-tor').onclick = () => setPolarization('tor');
    document.getElementById('btn-pol-bal').onclick = () => setPolarization('bal');
    document.getElementById('btn-pol-pol').onclick = () => setPolarization('pol');

    // --- MOUSE CONTROL ---
    let isDragging = false, lastX = 0, lastY = 0;
    canvas.addEventListener('mousedown', e => { isDragging = true; autoRotate = false; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mousemove', e => {
        if(!isDragging) return;
        STATE.camOrbit += (e.clientX - lastX) * 0.005;
        STATE.camTilt += (e.clientY - lastY) * 0.005;
        STATE.camTilt = Math.max(-Math.PI/2, Math.min(Math.PI/2, STATE.camTilt));
        lastX = e.clientX; lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        TARGET.camDist = Math.max(100, Math.min(5000, TARGET.camDist + e.deltaY));
    }, { passive: false });


    // --- MATH & COLOR ---
    const sin = Math.sin, cos = Math.cos, PI = Math.PI;

    function getElectronColor(t) {
        const r = Math.floor(sin(t * PI * 2) * 20);
        const g = Math.floor(sin(t * PI * 2) * 100 + 150);
        const b = 255;
        return `rgb(${r},${g},${b})`;
    }

    function getPhotonColor(t) {
        const r = 255;
        const g = Math.floor((sin(t * PI * 2) * 0.5 + 0.5) * 200); 
        const b = 0;
        return `rgb(${r},${g},${b})`;
    }

    function resize() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        STATE.width = canvas.width; STATE.height = canvas.height;
    }
    window.addEventListener('resize', resize);
    resize();

    function project(p) {
        let cx = p.x - STATE.camTarget.x;
        let cy = p.y - STATE.camTarget.y;
        let cz = p.z - STATE.camTarget.z;
        const rotX = cx * cos(STATE.camOrbit) - cz * sin(STATE.camOrbit);
        const rotZ = cx * sin(STATE.camOrbit) + cz * cos(STATE.camOrbit);
        const tilt = STATE.camTilt;
        const y_final = cy * cos(tilt) - rotZ * sin(tilt);
        const z_final = cy * sin(tilt) + rotZ * cos(tilt);
        const scale = STATE.camDist / (STATE.camDist + z_final + 50);
        return {
            x: STATE.width/2 + rotX * scale,
            y: STATE.height/2 + y_final * scale,
            scale: scale,
            z: z_final,
            visible: scale > 0
        };
    }

    // --- GENERATORS ---

    // 1. NUCLEUS
    function drawNucleus(ctx, t, scale) {
        const points = [];
        const latSteps = 12, lonSteps = 18;
        for(let i=0; i<=latSteps; i++) {
            const theta = (i/latSteps) * PI;
            for(let j=0; j<lonSteps; j++) {
                const phi = (j/lonSteps) * 2 * PI;
                const harmonic = sin(3 * theta) * cos(2 * phi);
                const pulse = sin(t * 12); 
                const r = scale * (1 + 0.15 * harmonic * pulse);
                const cBase = Math.floor(150 + 100 * harmonic * pulse);
                const isSmall = scale < 20;
                points.push({
                    x: r * sin(theta) * cos(phi),
                    y: r * cos(theta),
                    z: r * sin(theta) * sin(phi),
                    dir: {x:0, y:0, z:0},
                    type: isSmall ? 'nuc_dot' : 'nuc_arrow',
                    color: `rgb(${cBase}, 50, ${255-cBase})`
                });
            }
        }
        return points;
    }

    // 2. ELECTRON
    function drawElectron(ctx, t, scale) {
        const points = [];
        const ox=0, oy=0, oz=0;

        // A. OUTER SHELL (Recirculating DOWN visually)
        const lines = 12; 
        const segs = 8;
        for(let i=0; i<lines; i++) {
            const phi = (i/lines) * 2 * PI;
            for(let j=0; j<segs; j++) {
                // flowPhase 0->1.
                // theta = PI*(1-flowPhase). PI -> 0.
                // Cos(PI) = -1. Cos(0) = 1.
                // Y: -Scale to +Scale.
                // Screen: Top to Bottom. (DOWN)
                
                const flowPhase = (j/segs + t * 0.5) % 1.0; 
                const theta = PI * (1 - flowPhase); 

                const r_pol = scale * 1.0; 
                
                const lx = r_pol * sin(theta) * cos(phi);
                const ly = r_pol * cos(theta); 
                const lz = r_pol * sin(theta) * sin(phi);

                // Tangent calculation (Down/Following Curve)
                // Use nextTheta (smaller theta, closer to 0/Top? Wait.)
                // If theta goes PI->0.
                // Next theta should be smaller? Yes.
                const nextTheta = theta - 0.1;
                // Wait, if it moves PI->0, it moves -Scale -> +Scale? 
                // Cos(PI)=-1, Cos(0)=1. 
                // -Scale to +Scale. This is DOWN.
                
                const nx = r_pol * sin(nextTheta) * cos(phi);
                const ny = r_pol * cos(nextTheta);
                const nz = r_pol * sin(nextTheta) * sin(phi);

                points.push({
                    x: ox + lx, y: oy + ly, z: oz + lz,
                    dir: {x: nx-lx, y: ny-ly, z: nz-lz}, 
                    type: 'elec_shell',
                    color: getElectronColor(flowPhase),
                    alpha: 0.7
                });
            }
        }

        // B. THE CORE (FLIPPED: NOW MOVING UP)
        const coreSegs = 7;
        for(let j=0; j<coreSegs; j++) {
            const phase = (t * 2.0 + j/coreSegs) % 1.0; 
            
            // FLIPPED LOGIC:
            // Previous: -Scale to +Scale (Down).
            // New: +Scale to -Scale (Up).
            // Start at 1.2, end at -1.2
            const y_pos = scale*1.2 - (phase * 2.4 * scale);
            
            if(Math.abs(y_pos) > scale) continue;

            points.push({
                x: ox, y: oy + y_pos, z: oz,
                dir: {x: 0, y: -1, z: 0}, // FLIPPED ARROW: UP
                type: 'elec_core',
                color: '#ff0000',
                alpha: 1.0
            });
        }
        return points;
    }

    // 3. PHOTON
    function drawPhoton(ctx, phaseTor, phasePol, scale) {
        const points = [];
        const ox=0, oy=0, oz=0;
        const rings = 40; 
        const tubeR = scale * 0.25; 
        const majorR = scale; 

        for(let i=0; i<rings; i++) {
            const u = (i/rings) * 2 * PI + (phaseTor * 2.0); 
            
            for(let k=0; k<8; k++) {
                const phaseOffset = k * (PI / 4); 
                const flow = (phasePol * 6.0 + i * 0.1 + phaseOffset) % (2 * PI);
                const colorPhase = (flow / (2*PI)); 
                
                const cx = (majorR + tubeR * cos(flow)) * cos(u);
                const cy = tubeR * sin(flow);
                const cz = (majorR + tubeR * cos(flow)) * sin(u);

                const tx = -sin(flow) * cos(u);
                const ty = cos(flow);
                const tz = -sin(flow) * sin(u);

                points.push({
                    x: ox + cx, y: cy, z: oz + cz,
                    dir: {x: tx, y: ty, z: tz},
                    type: 'phot',
                    color: getPhotonColor(colorPhase),
                    alpha: 0.9
                });
            }
        }
        return points;
    }

    // --- LOOP ---
    function loop() {
        const dt = 0.003;
        STATE.time += dt; 
        if(autoRotate) STATE.camOrbit += 0.001; 
        
        const spd = 0.05;
        STATE.vTor += (TARGET.vTor - STATE.vTor) * spd;
        STATE.vPol += (TARGET.vPol - STATE.vPol) * spd;
        STATE.phaseTor += STATE.vTor * dt;
        STATE.phasePol += STATE.vPol * dt;

        STATE.camDist += (TARGET.camDist - STATE.camDist) * spd;
        STATE.scaleNuc += (TARGET.scaleNuc - STATE.scaleNuc) * spd;
        STATE.scaleElec += (TARGET.scaleElec - STATE.scaleElec) * spd;
        STATE.scalePhot += (TARGET.scalePhot - STATE.scalePhot) * spd;
        STATE.opacityNuc += (TARGET.opacityNuc - STATE.opacityNuc) * spd;
        STATE.opacityElec += (TARGET.opacityElec - STATE.opacityElec) * spd;
        STATE.opacityPhot += (TARGET.opacityPhot - STATE.opacityPhot) * spd;

        let points = [];
        if(STATE.opacityNuc > 0.01) points = points.concat(drawNucleus(ctx, STATE.time, STATE.scaleNuc));
        if(STATE.opacityElec > 0.01) points = points.concat(drawElectron(ctx, STATE.time, STATE.scaleElec));
        if(STATE.opacityPhot > 0.01) points = points.concat(drawPhoton(ctx, STATE.phaseTor, STATE.phasePol, STATE.scalePhot));

        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, STATE.width, STATE.height);

        const renderList = points.map(p => {
            const proj = project(p);
            let vEnd;
            if(p.type === 'nuc_arrow') vEnd = {x: p.x*1.2, y: p.y*1.2, z: p.z*1.2};
            else if(p.type === 'nuc_dot') vEnd = {x: p.x, y: p.y, z: p.z}; 
            else if(p.type === 'elec_core') vEnd = {x: p.x, y: p.y + p.dir.y*STATE.scaleElec*0.15, z: p.z}; 
            else if(p.type === 'elec_shell') vEnd = {x: p.x + p.dir.x*3, y: p.y + p.dir.y*3, z: p.z + p.dir.z*3}; 
            else {
                const len = (p.type==='phot' ? STATE.scalePhot : STATE.scaleElec) * 0.25;
                vEnd = {x: p.x + p.dir.x * len, y: p.y + p.dir.y * len, z: p.z + p.dir.z * len};
            }
            const projEnd = project(vEnd);
            return { ...p, px: proj.x, py: proj.y, pz: proj.z, scale: proj.scale,
                     angle: Math.atan2(projEnd.y - proj.y, projEnd.x - proj.x),
                     visible: proj.visible };
        });

        renderList.sort((a, b) => b.pz - a.pz);

        renderList.forEach(p => {
            if(!p.visible) return;
            
            let globalOp = 1;
            if(p.type.includes('nuc')) globalOp = STATE.opacityNuc;
            if(p.type.includes('elec')) globalOp = STATE.opacityElec;
            if(p.type.includes('phot')) globalOp = STATE.opacityPhot;
            if(globalOp < 0.05) return;

            const alpha = (p.alpha ? p.alpha : Math.min(1, Math.max(0.2, p.scale))) * globalOp;
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = p.color;
            ctx.fillStyle = p.color;
            ctx.lineWidth = (p.type === 'elec_core') ? 2 : 1; 

            ctx.save();
            ctx.translate(p.px, p.py);
            
            if(p.type === 'nuc_dot') {
                ctx.beginPath();
                ctx.arc(0, 0, 3 * p.scale, 0, PI*2);
                ctx.fill();
            } else {
                ctx.rotate(p.angle);
                const size = (p.type==='elec_core' ? 25 : 15) * p.scale;
                
                ctx.beginPath();
                ctx.moveTo(-size/2, 0);
                ctx.lineTo(size/2, 0);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(size/2, 0);
                ctx.lineTo(size/2 - 5 * p.scale, -3 * p.scale);
                ctx.lineTo(size/2 - 5 * p.scale, 3 * p.scale);
                ctx.fill();
            }
            ctx.restore();
        });

        requestAnimationFrame(loop);
    }
    setActive('schematic');
    loop();

})();
</script>
</body>
</html>