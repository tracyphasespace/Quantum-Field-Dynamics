<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Field Dynamics: Driven Nonlinear Oscillator</title>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for Mouse Interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            max-width: 340px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.2);
            pointer-events: auto;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #4facfe; text-shadow: 0 0 10px rgba(79, 172, 254, 0.5); }
        p { font-size: 0.9rem; color: #ddd; margin-bottom: 15px; line-height: 1.4; }
        .instructions { font-size: 0.8rem; color: #aaa; font-style: italic; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        button {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            font-size: 0.95rem;
            font-weight: 500;
        }
        button:hover { background: #333; border-color: #666; transform: translateX(2px); }
        button.active {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: #000;
            border: none;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.4);
        }
        #status {
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #00f2fe;
            font-weight: bold;
        }
        .legend { display: flex; align-items: center; margin-top: 8px; font-size: 0.85rem; color: #eee; }
        .dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; }
    </style>
</head>
<body>

<div id="ui-container">
    <h1>Vortex Dynamics</h1>
    <p>Driven Nonlinear Oscillator<br>Absorption & Emission Cycles</p>
    <div class="instructions">
        • Left Click: Rotate View<br>
        • Right Click: Pan<br>
        • Scroll: Zoom
    </div>
    
    <button id="btn-low" class="active" onclick="setMode(0)">1. Ground State (Stable)</button>
    <button id="btn-chaos" onclick="setMode(1)">2. Absorb Photon (Excited)</button>
    <button id="btn-eject" onclick="setMode(2)">3. Eject Photon (2s Timer)</button>

    <div id="status">State: Ground State (n=1)</div>

    <div style="margin-top: 20px; border-top: 1px solid #444; padding-top: 10px;">
        <div class="legend"><div class="dot" style="background: rgba(0, 255, 255, 0.8); border: 1px solid #fff;"></div> Electron (R=20)</div>
        <!-- Red Box Removed from Legend -->
        <div class="legend"><div class="dot" style="background: #ff3333"></div> Fixed Proton</div>
        <div class="legend"><div class="dot" style="background: gold"></div> Photon Soliton</div>
    </div>
</div>

<script>
    // --- Physics Parameters ---
    const PHYS = {
        R: 20.0,            // Electron Radius (R)
        p: 1.0,             // Density exponent
        k: 4000.0,          // Central Force Strength
        
        // Drive Parameters 
        E0: 0.0,            
        Omega: 0.8,         
        gamma: 0.002,       
        
        // STAGE 2 PARAMETERS
        E0_excited: 5.0,    // Increased drive to sustain large orbit
        B0_excited: 0.15,   // Gentle magnetic precession
        k_excited: 0.3,     // Reduced spring constant to allow wider travel
        
        R_limit: 100.0      
    };

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.0002); 

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
    camera.position.set(0, 150, 400); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- Controls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 10;
    controls.maxDistance = 10000; 

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 1.2, 500);
    scene.add(pointLight);

    const flashLight = new THREE.PointLight(0xffffaa, 0, 3000);
    scene.add(flashLight);

    // --- Objects ---

    // 1. The Electron (Cloud/Shell)
    const electronGeo = new THREE.IcosahedronGeometry(1, 2); 
    const electronMat = new THREE.MeshPhongMaterial({
        color: 0x00ffff,        
        transparent: true,
        opacity: 0.2,          
        wireframe: true,
        side: THREE.DoubleSide,
        emissive: 0x0044aa,
        emissiveIntensity: 0.4
    });
    const electronCloud = new THREE.Mesh(electronGeo, electronMat);
    electronCloud.scale.setScalar(PHYS.R); 
    scene.add(electronCloud);

    // Inner Glow
    const glowGeo = new THREE.SphereGeometry(0.9, 32, 32);
    const glowMat = new THREE.MeshBasicMaterial({
        color: 0x0066ff,
        transparent: true,
        opacity: 0.05,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide
    });
    const innerGlow = new THREE.Mesh(glowGeo, glowMat);
    electronCloud.add(innerGlow);

    // 2. The Proton (Hard Core)
    const protonGeo = new THREE.SphereGeometry(2.5, 32, 32); 
    const protonMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8,
        roughness: 0.2
    });
    const proton = new THREE.Mesh(protonGeo, protonMat);
    scene.add(proton); 

    // 3. DEBUG BOUNDARY SPHERE (Now Hidden by default/logic)
    const debugGeo = new THREE.SphereGeometry(PHYS.R_limit, 32, 32);
    const debugMat = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        transparent: true,
        opacity: 0.15
    });
    const debugSphere = new THREE.Mesh(debugGeo, debugMat);
    debugSphere.visible = false; // Always hidden per request
    scene.add(debugSphere);

    // 4. The INCOMING Photon (Absorption)
    const inPhotonGeo = new THREE.TorusGeometry(10, 2, 16, 50);
    const inPhotonMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.9 
    });
    const inPhoton = new THREE.Mesh(inPhotonGeo, inPhotonMat);
    inPhoton.visible = false;
    scene.add(inPhoton);

    // 5. The OUTGOING Photon (Emission)
    const photonGeo = new THREE.TorusGeometry(16, 4, 32, 100);
    const photonMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
    const photon = new THREE.Mesh(photonGeo, photonMat);
    photon.visible = false;
    scene.add(photon);

    // 6. Trail
    const MAX_TRAIL_POINTS = 8000; 
    const trailGeo = new THREE.BufferGeometry();
    const trailPositions = new Float32Array(MAX_TRAIL_POINTS * 3);
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    const trailMat = new THREE.LineBasicMaterial({
        color: 0x00ff00,    
        transparent: true,
        opacity: 0.6,
    });
    const trail = new THREE.Line(trailGeo, trailMat);
    scene.add(trail);

    // --- State ---
    let state = {
        mode: 0, 
        pos: new THREE.Vector3(PHYS.R * 0.8, 0, 0), 
        vel: new THREE.Vector3(0, 0, 5.0), 
        time: 0,
        currentB: 0, 
        
        // Absorption State
        absorptionActive: false,
        absorbProgress: 0.0, 
        
        // Ejection State
        photonPos: new THREE.Vector3(),
        photonVel: new THREE.Vector3(),
        photonActive: false,
        ejectionTimer: null
    };

    // --- Interaction ---
    function setMode(mode) {
        state.mode = mode;
        if (state.ejectionTimer) clearTimeout(state.ejectionTimer);

        document.querySelectorAll('button').forEach((b, i) => {
            if (i === mode) b.classList.add('active');
            else b.classList.remove('active');
        });

        const statusDiv = document.getElementById('status');
        
        if (mode === 0) {
            // --- GROUND STATE ---
            statusDiv.innerText = "State: Ground State (Stable)";
            statusDiv.style.color = "#4facfe";
            
            PHYS.E0 = 0.0;    
            state.currentB = 0.0;
            debugSphere.visible = false;
            
            clearTrail();
            moveCameraTo(400);

            // Stabilize orbit
            state.pos.setLength(PHYS.R * 0.8);
            state.vel.set(0, 0, Math.sqrt(PHYS.k / state.pos.length())); 
            
            if (!state.photonActive) photon.visible = false;
            inPhoton.visible = false;
        } 
        else if (mode === 1) {
            // --- EXCITED STATE (Transition) ---
            statusDiv.innerText = "State: Incoming Photon (Top-Left)...";
            statusDiv.style.color = "#00ffff";
            
            // Start Absorption Animation
            state.absorptionActive = true;
            state.absorbProgress = 0.0;
            
            // Start position (Top Left, far out)
            inPhoton.position.set(-300, 300, 0);
            inPhoton.scale.setScalar(4.0);
            inPhoton.visible = true;
            inPhoton.lookAt(0,0,0);
            
            moveCameraTo(800);
        } 
        else if (mode === 2) {
            // --- EJECTION TIMER ---
            statusDiv.innerText = "State: Locking... Ejection in 2s";
            statusDiv.style.color = "#ffd700";
            
            // Force ejection after 2 seconds
            state.ejectionTimer = setTimeout(forceFirePhoton, 2000);
        }
    }

    function clearTrail() {
        const positions = trail.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i++) positions[i] = 0;
        trail.geometry.attributes.position.needsUpdate = true;
        trailIdx = 0;
    }

    function moveCameraTo(zDist) {
        const startZ = camera.position.z;
        const startY = camera.position.y;
        const startTime = Date.now();
        const duration = 1000;

        function animateCam() {
            const now = Date.now();
            const progress = Math.min((now - startTime) / duration, 1.0);
            const ease = 1 - Math.pow(1 - progress, 3);
            
            camera.position.z = startZ + (zDist - startZ) * ease;
            camera.position.y = startY + (zDist * 0.35 - startY) * ease;
            camera.lookAt(0,0,0);

            if (progress < 1.0) requestAnimationFrame(animateCam);
        }
        animateCam();
    }

    // --- Physics Engine (RK4) ---
    function accelAt(pos, vel, t) {
        const r = pos.length();
        let a = new THREE.Vector3();

        if (r > 1e-9) {
            // CENTRAL FORCE (Dominant)
            if (r < PHYS.R) {
                // INSIDE: Soft Core
                const mag = PHYS.k * Math.pow(r, PHYS.p) / Math.pow(PHYS.R, PHYS.p + 2.0);
                const insideFactor = (state.mode === 1) ? 0.5 : 1.0; 
                a.copy(pos).multiplyScalar(-mag * insideFactor); 
            } else {
                // OUTSIDE: Coulomb
                if (state.mode === 0) {
                     const mag = PHYS.k / (r*r*r);
                     a.copy(pos).multiplyScalar(-mag); 
                } else {
                     // Excited State
                     a.copy(pos).normalize().multiplyScalar(-PHYS.k_excited * r); 
                }
            }
        }

        // Drive (External Field)
        if (PHYS.E0 > 0) {
            a.x += PHYS.E0 * Math.cos(PHYS.Omega * t);
        }

        // Magnetic (Lorentz)
        if (state.currentB > 0) {
            a.x += vel.y * state.currentB;
            a.y -= vel.x * state.currentB;
        }

        // Damping
        const gamma = (state.mode === 0) ? 0.0 : PHYS.gamma;
        a.addScaledVector(vel, -gamma);

        // Soft Wall at Red Boundary
        if (state.mode !== 0 && r > PHYS.R_limit) {
             const pen = r - PHYS.R_limit;
             a.addScaledVector(pos.clone().normalize(), -10.0 * pen);
        }

        return a;
    }

    function stepRK4(dt) {
        const r0 = state.pos.clone();
        const v0 = state.vel.clone();
        const t0 = state.time;

        const a0 = accelAt(r0, v0, t0);
        const r1 = r0.clone().addScaledVector(v0, 0.5*dt);
        const v1 = v0.clone().addScaledVector(a0, 0.5*dt);
        const a1 = accelAt(r1, v1, t0 + 0.5*dt);
        const r2 = r0.clone().addScaledVector(v1, 0.5*dt);
        const v2 = v0.clone().addScaledVector(a1, 0.5*dt);
        const a2 = accelAt(r2, v2, t0 + 0.5*dt);
        const r3 = r0.clone().addScaledVector(v2, dt);
        const v3 = v0.clone().addScaledVector(a2, dt);
        const a3 = accelAt(r3, v3, t0 + dt);

        const dr = v0.clone().add(v1.clone().multiplyScalar(2)).add(v2.clone().multiplyScalar(2)).add(v3).multiplyScalar(dt/6);
        const dv = a0.clone().add(a1.clone().multiplyScalar(2)).add(a2.clone().multiplyScalar(2)).add(a3).multiplyScalar(dt/6);

        state.pos.add(dr);
        state.vel.add(dv);
        state.time += dt;
    }

    function updatePhysics() {
        const subSteps = 20; 
        const dt = 0.02;     
        const stepDt = dt / subSteps;
        
        // --- Handle Absorption Animation ---
        if (state.absorptionActive) {
            // Speed of absorption
            state.absorbProgress += 0.02; 
            
            // Linear interpolation from Start (-300, 300) to Center (0,0)
            const startPos = new THREE.Vector3(-300, 300, 0);
            const endPos = new THREE.Vector3(0, 0, 0);
            inPhoton.position.lerpVectors(startPos, endPos, state.absorbProgress);
            
            // Scale down slightly as it hits
            const scale = 4.0 * (1.0 - state.absorbProgress * 0.5); 
            inPhoton.scale.setScalar(scale);

            if (state.absorbProgress >= 1.0) {
                // IMPACT!
                state.absorptionActive = false;
                inPhoton.visible = false;
                
                PHYS.E0 = PHYS.E0_excited; 
                state.currentB = PHYS.B0_excited;
                // Debug Sphere stays HIDDEN in this version
                debugSphere.visible = false;
                
                const statusDiv = document.getElementById('status');
                if(statusDiv) {
                    statusDiv.innerText = "State: Excited! (Energy Injected)";
                    statusDiv.style.color = "#ff66cc";
                }
                
                // MASSIVE KICK
                const kick = state.vel.clone().normalize().multiplyScalar(40.0); 
                state.vel.add(kick);
            }
        }

        for(let s=0; s<subSteps; s++) {
            if (state.photonActive) break; 
            stepRK4(stepDt);
        }
        
        // Photon Logic
        if (state.photonActive) {
            state.photonPos.add(state.photonVel);
            photon.position.copy(state.photonPos);
            
            const lookTarget = state.photonPos.clone().add(state.photonVel);
            photon.lookAt(lookTarget); 
            photon.scale.setScalar(1 + state.photonPos.length()*0.0005);
            
            if (state.photonPos.length() > 3000) { 
                state.photonActive = false;
                photon.visible = false;
            }
        }
    }

    function forceFirePhoton() {
        state.photonActive = true;
        photon.visible = true;
        
        state.photonPos.set(0,0,0);
        // Fire in direction of electron velocity
        const fireDir = state.vel.clone().normalize();
        state.photonVel = fireDir.multiplyScalar(4.0); 
        
        // --- RECOIL & RESET TO GROUND STATE ---
        flashLight.intensity = 8;
        
        // 1. Switch Logic to Ground State
        state.mode = 0; 
        PHYS.E0 = 0.0;
        state.currentB = 0.0;
        debugSphere.visible = false;
        
        // 2. Quantum Jump: Instant reset to Ground Orbit
        // Place electron at stable radius with stable velocity
        const resetAngle = Math.random() * Math.PI * 2;
        state.pos.set(Math.cos(resetAngle) * PHYS.R * 0.8, Math.sin(resetAngle) * PHYS.R * 0.8, 0);
        
        // Circular velocity for this radius
        const vMag = Math.sqrt(PHYS.k / state.pos.length());
        state.vel.set(-Math.sin(resetAngle)*vMag, Math.cos(resetAngle)*vMag, 0);
        
        document.querySelectorAll('button').forEach((b, i) => {
            if (i === 0) b.classList.add('active'); 
            else b.classList.remove('active');
        });

        const statusDiv = document.getElementById('status');
        if(statusDiv) {
            statusDiv.innerText = "VORTEX EJECTED! Recoil to Ground State.";
            statusDiv.style.color = "#ffd700";
        }
        
        // Auto zoom back in
        moveCameraTo(400);
    }

    // --- Rendering Loop ---
    let trailIdx = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        controls.update(); 
        updatePhysics();

        if (flashLight.intensity > 0) flashLight.intensity *= 0.92;

        electronCloud.position.copy(state.pos);

        // Pulse Electron slightly
        const time = Date.now() * 0.002;
        electronCloud.rotation.y = time * 0.05;

        // Update Trail
        if (!state.photonActive) {
            const positions = trail.geometry.attributes.position.array;
            positions[trailIdx * 3] = state.pos.x;
            positions[trailIdx * 3 + 1] = state.pos.y;
            positions[trailIdx * 3 + 2] = state.pos.z;
            trailIdx = (trailIdx + 1) % MAX_TRAIL_POINTS;
            trail.geometry.attributes.position.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initialize
    setMode(0);

    animate();

</script>
</body>
</html>