<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Elliptical Binary Outflow Viewer</title>
  <style>
    body { margin:0; background:#0f172a; color:#cbd5e1; font-family:Inter,sans-serif; }
    #controls { padding:1rem; display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:1rem; background:#1e293b; }
    #canvas { display:block; width:100%; height:calc(100vh - 260px); background:#0f172a; }
    input[type=range] { width:100%; }
    .checkbox { display:flex; align-items:center; }
    .checkbox input { margin-right:.5rem; }
    button { background:#3b82f6; color:#fff; padding:.5rem; border:none; border-radius:.25rem; cursor:pointer; }
    small { color:#94a3b8; display:block; font-size:.75rem; }
    label { font-size:.9rem; }
  </style>
</head>
<body>
  <div id="controls">
    <div><label>M1: <span id="m1Val">1375</span></label><input id="m1" type="range" min="500" max="5000" value="1375"></div>
    <div><label>M2: <span id="m2Val">500</span></label><input id="m2" type="range" min="100" max="2000" value="500"></div>
    <div><label>Separation: <span id="dVal">195</span></label><input id="d" type="range" min="100" max="400" value="195"></div>
    <div>
      <label>Speed: <span id="vVal">0.80</span></label>
      <input id="v" type="range" min="0.10" max="2.00" step="0.01" value="0.80">
      <small>fraction of circular</small>
    </div>
    <div><label>Prox: <span id="pVal">150</span></label><input id="p" type="range" min="50" max="300" step="10" value="150"></div>
    <div><label>Boost: <span id="bVal">1.0</span></label><input id="b" type="range" min="0.5" max="5.0" step="0.1" value="1.0"></div>
    <div>
      <label>Aperture: <span id="aVal">1.5°</span></label><input id="a" type="range" min="0.5" max="10" step="0.5" value="1.5">
      <small>half‑angle</small>
    </div>
    <div>
      <label>Time: <span id="tVal">5.0×</span></label><input id="t" type="range" min="0.2" max="10.0" step="0.1" value="5.0">
      <small>world speed</small>
    </div>
    <div>
      <label>Particles: <span id="countVal">10000</span></label><input id="count" type="range" min="50" max="50000" step="10" value="10000">
      <small>max</small>
    </div>
    <div>
      <label>Rate: <span id="rVal">10/sec</span></label><input id="r" type="range" min="1" max="100" step="1" value="10">
      <small>spawn/sec</small>
    </div>
    <div class="checkbox"><input type="checkbox" id="dual"><label for="dual">Dual Outflow</label></div>
    <div style="align-self:center;text-align:center;"><button id="restart">Restart</button></div>
  </div>
  <canvas id="canvas"></canvas>
  <script>
  // DOM & labels
  const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
  const sliders = ['m1','m2','d','v','p','b','a','t','count','r'];
  const labelMap = { m1:'m1Val',m2:'m2Val',d:'dVal',v:'vVal',p:'pVal',b:'bVal',a:'aVal',t:'tVal',count:'countVal',r:'rVal' };
  sliders.forEach(id=>{
    const s=document.getElementById(id), l=document.getElementById(labelMap[id]);
    s.oninput = ()=>{
      if(id==='v'||id==='b')       l.textContent = parseFloat(s.value).toFixed(2);
      else if(id==='a')             l.textContent = s.value+'°';
      else if(id==='t')             l.textContent = parseFloat(s.value).toFixed(1)+'×';
      else if(id==='r')             l.textContent = s.value+'/sec';
      else                           l.textContent = s.value;
    };
  });
  document.getElementById('restart').onclick = start;

  // Vec helpers
  function sub(a,b){return{x:a.x-b.x,y:a.y-b.y};}
  function mag(v){return Math.hypot(v.x,v.y);}
  function norm(v){const m=mag(v);return m<1e-9?{x:0,y:0}:{x:v.x/m,y:v.y/m};}
  function scale(v,s){return{x:v.x*s,y:v.y*s};}

  // Color banding
  function pickColorByDistance(d){
    const r=d/threshold;
    if(r>=0.5) return '#fde047';
    if(r>=0.25) return '#a3e635';
    if(r>=0.125) return '#38bdf8';
    if(r>=0.0625) return '#1e3a8a';
    if(r>=0.03125) return '#8b5cf6';
    if(r>=0.015625) return '#f43f5e';
    return '#7f1d1d';
  }

  // Mass & Particle
  class Mass {
    constructor(x,y,m,r,c){
      this.pos={x,y};this.mass=m;this.radius=r;this.color=c;
      this.vel={x:0,y:0};this.acc={x:0,y:0};
    }
    applyForce(f){
      if(!isFinite(f.x)||!isFinite(f.y))return;
      this.acc.x+=f.x/this.mass;this.acc.y+=f.y/this.mass;
    }
    update(dt){
      this.vel.x+=this.acc.x*dt;this.vel.y+=this.acc.y*dt;
      this.pos.x+=this.vel.x*dt;this.pos.y+=this.vel.y*dt;
      this.acc={x:0,y:0};
    }
    draw(){
      ctx.beginPath();
      ctx.arc(this.pos.x,this.pos.y,this.radius,0,2*Math.PI);
      ctx.fillStyle=this.color;ctx.fill();
    }
  }

  class Particle {
    constructor(x,y,vx,vy,clr){
      this.pos={x,y};this.vel={x:vx,y:vy};this.acc={x:0,y:0};
      this.color=clr;
    }
    applyForce(f){
      if(!isFinite(f.x)||!isFinite(f.y))return;
      this.acc.x+=f.x/0.1;this.acc.y+=f.y/0.1;
    }
    update(dt){
      this.vel.x+=this.acc.x*dt;this.vel.y+=this.acc.y*dt;
      this.pos.x+=this.vel.x*dt;this.pos.y+=this.vel.y*dt;
      this.acc={x:0,y:0};
    }
    draw(){
      ctx.beginPath();
      ctx.arc(this.pos.x,this.pos.y,1.5,0,2*Math.PI);
      ctx.fillStyle=this.color;ctx.fill();
    }
  }

  // State
  let primary, secondary, particles;
  let entry, pericenter, exitPos, minD, prevIn=false, spawnAcc=0;
  let threshold;
  const BASE_DT=0.05, SOFT=20, G=1;

  function resize(){
    canvas.width=window.innerWidth;
    canvas.height=window.innerHeight-document.getElementById('controls').offsetHeight;
  }

  function init(){
    resize();
    particles=[];entry=pericenter=exitPos=null;minD=Infinity;prevIn=false;spawnAcc=0;

    const M1    =+m1.value,
          M2    =+m2.value,
          Dsep  =+d.value,
          speedFrac=+v.value,
          Pprox =+p.value,
          Boost =+b.value,
          Apert =+a.value*Math.PI/180,
          TS    =+t.value,
          MAXP  =+count.value,
          RATE  =+r.value,
          DUAL  =document.getElementById('dual').checked;

    // center
    const cx=canvas.width/2, cy=canvas.height/2;
    // COM distances
    const r1=Dsep*(M2/(M1+M2)), r2=Dsep*(M1/(M1+M2));
    primary   = new Mass(cx-r1, cy, M1, Math.cbrt(M1)*0.8,'#0ea5e9');
    secondary = new Mass(cx+r2, cy, M2, Math.cbrt(M2)*0.8,'#f97316');

    // circular speed
    const vCirc = Math.sqrt(G*(M1+M2)/Dsep),
          vRel  = vCirc * speedFrac;

    const sep = sub(secondary.pos, primary.pos),
          rHat= norm(sep),
          perp= { x:-rHat.y, y:rHat.x };

    // elliptical velocities
    primary.vel.x   =  perp.x * vRel * (M2/(M1+M2));
    primary.vel.y   =  perp.y * vRel * (M2/(M1+M2));
    secondary.vel.x = -perp.x * vRel * (M1/(M1+M2));
    secondary.vel.y = -perp.y * vRel * (M1/(M1+M2));

    threshold = Dsep * 3;

    // stash
    Particle._boost=Boost;
    Particle._cone =Apert;
    Particle._max  =MAXP;
    Particle._rate =RATE;
    Particle._dual =DUAL;
    Mass._dtMul    =TS;
  }

  function calcForce(a,b){
    const r=sub(a.pos,b.pos),
          d2=r.x*r.x+r.y*r.y+SOFT*SOFT,
          f =(G*a.mass*b.mass)/d2,
          dir=norm(r);
    return scale(dir,f);
  }

  function spawnFrom(mass,axisSource){
    if(particles.length>=Particle._max)return;
    const base=norm(sub(axisSource.pos,mass.pos)),
          δ=(Math.random()*2-1)*Particle._cone,
          c=Math.cos(δ),s=Math.sin(δ),
          dir={x:base.x*c-base.y*s,y:base.x*s+base.y*c};
    if(dir.x*base.x+dir.y*base.y<0){dir.x*=-1;dir.y*=-1;}

    const boost=Particle._boost*(0.8+0.4*Math.random()),
          offset=mass.radius+5+(Math.random()-0.5)*mass.radius*0.2,
          sx=mass.pos.x+dir.x*offset,
          sy=mass.pos.y+dir.y*offset,
          vx=dir.x*boost*2,
          vy=dir.y*boost*2,
          dsrc=mag(sub(axisSource.pos,primary.pos)),
          color=pickColorByDistance(dsrc);

    particles.push(new Particle(sx,sy,vx,vy,color));
  }

  function spawnParticle(){
    spawnFrom(primary,secondary);
    if(Particle._dual) spawnFrom(secondary,primary);
  }

  function update(){
    const dt=BASE_DT*+t.value;
    // compute F on secondary by primary
    const f12 = calcForce(primary,secondary);
    // apply opposite to primary, and f12 to secondary
    primary.applyForce(scale(f12,-1));
    secondary.applyForce(f12);

    primary.update(dt);
    secondary.update(dt);

    // proximity markers
    const d=mag(sub(secondary.pos,primary.pos)), inP=d<+p.value;
    if(inP&&!prevIn){entry={...secondary.pos};pericenter=null;minD=d;spawnAcc=0;}
    if(inP&&d<minD){minD=d;pericenter={...secondary.pos};}
    if(!inP&&prevIn){exitPos={...secondary.pos};}
    prevIn=inP;

    // spawn
    if(inP){
      spawnAcc+=Particle._rate*dt;
      while(spawnAcc>=1){spawnParticle();spawnAcc--;}
    }

    // update/prune
    particles=particles.filter(p=>{
      p.applyForce(calcForce(primary,p));
      p.applyForce(calcForce(secondary,p));
      p.update(dt);
      return mag(sub(p.pos,primary.pos))<threshold;
    });
  }

  function drawMarker(pos,color){
    if(!pos)return;
    ctx.strokeStyle=color;ctx.lineWidth=1.5;
    const s=6;
    ctx.beginPath();
    ctx.moveTo(pos.x-s,pos.y);ctx.lineTo(pos.x+s,pos.y);
    ctx.moveTo(pos.x,pos.y-s);ctx.lineTo(pos.x,pos.y+s);
    ctx.stroke();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // axis line
    const v=norm(sub(secondary.pos,primary.pos));
    ctx.strokeStyle='rgba(255,255,255,0.25)';
    ctx.beginPath();
    ctx.moveTo(primary.pos.x,primary.pos.y);
    ctx.lineTo(primary.pos.x+v.x*100,primary.pos.y+v.y*100);
    ctx.stroke();

    primary.draw();
    secondary.draw();
    particles.forEach(p=>p.draw());

    drawMarker(entry,'lime');
    drawMarker(pericenter,'yellow');
    drawMarker(exitPos,'red');
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  function start(){ init(); loop(); }

  window.onresize=resize;
  window.onload=start;
  </script>
</body>
</html>
