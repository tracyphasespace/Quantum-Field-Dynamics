#!/usr/bin/env python3
"""
hessian_v7_rotor_angular.py -- Rotor-based angular decomposition (GA-native)

MOTIVATION (from v6):
    The second-order Hessian factorizes: H = diag(σ_A) ⊗ (-∇²) + H_V(r).
    No grade coupling → scalar reduction is complete → wrong ratio.

    But the Dirac angular eigenvalues κ² = (ℓ+3)² differ from scalar
    ℓ(ℓ+4)+15/4, giving ℓ=2/ℓ=0 ratio = 0.472 (closer to 0.235 target).
    The target lies between Dirac ℓ=2 (0.472) and ℓ=3 (0.152).

    This script implements the PROPER angular decomposition using:
    1. L_ij bivector generators as 64×64 matrices
    2. SO(3)_space × SO(3)_time Casimir decomposition
    3. Full coupled angular-radial eigenvalue problem

    The key physics: in the multivector representation, angular modes
    carry INTERNAL spin from the grade structure. The total angular
    momentum couples orbital ℓ with internal spin s, giving effective
    angular eigenvalues that depend on (ℓ, s, j) quantum numbers.

Copyright (c) 2026 Tracy McSheery
Licensed under the MIT License
"""

import sys
import os
import numpy as np
from scipy.linalg import eigh_tridiagonal, eigh, block_diag
from scipy.sparse.linalg import eigsh
from scipy import sparse

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', '..'))
from qfd.shared_constants import ALPHA, BETA
from qfd.Cl33 import (Multivector, N_COMPONENTS, SIGNATURE,
                       geometric_product_indices, basis_grade,
                       e0, e1, e2, e3, e4, e5, B_phase,
                       commutes_with_phase)


# =============================================================================
# PARAMETERS
# =============================================================================

beta = BETA
lam = beta
rho_0 = 1.0
a = 1.0
U_circ = np.sqrt(beta) / 2.0
d_eff = 6.0


# =============================================================================
# GA UTILITIES (from v6)
# =============================================================================

def reverse_mv(psi):
    """Compute the reverse ψ̃."""
    result = Multivector()
    for idx in range(N_COMPONENTS):
        grade = basis_grade(idx)
        sign = (-1) ** (grade * (grade - 1) // 2)
        result.components[idx] = sign * psi.components[idx]
    return result


def compute_internal_metric():
    """64×64 internal metric G[A,B] = ⟨ẽ_A e_B⟩₀."""
    G = np.zeros((N_COMPONENTS, N_COMPONENTS))
    for A in range(N_COMPONENTS):
        eA_rev = reverse_mv(Multivector.basis_element(A))
        for B in range(N_COMPONENTS):
            eB = Multivector.basis_element(B)
            G[A, B] = (eA_rev * eB).scalar_part()
    return G


# =============================================================================
# PHASE 1: BIVECTOR ANGULAR MOMENTUM GENERATORS L_ij
# =============================================================================

def compute_bivector_generators():
    """Compute the 15 bivector generators L_ij as 64×64 matrices.

    The rotation generated by bivector e_i ∧ e_j acts on multivectors by:
        L_{ij}(ψ) = ½[e_i e_j, ψ] = ½(e_i e_j ψ - ψ e_i e_j)

    In matrix form:
        L_{ij}[A,B] = ½(⟨ẽ_A (e_i e_j) e_B⟩₀ - ⟨ẽ_A e_B (e_i e_j)⟩₀)
    which simplifies to the commutator action projected onto basis.
    """
    L = {}  # L[(i,j)] = 64×64 matrix

    for i in range(6):
        ei = Multivector.basis(i)
        for j in range(i + 1, 6):
            ej = Multivector.basis(j)
            bij = ei * ej  # Bivector e_i e_j

            L_ij = np.zeros((N_COMPONENTS, N_COMPONENTS))
            for B in range(N_COMPONENTS):
                eB = Multivector.basis_element(B)

                # L_{ij}(e_B) = ½(bij * eB - eB * bij) = ½[bij, eB]
                comm = bij * eB - eB * bij
                result_mv = comm * 0.5

                for A in range(N_COMPONENTS):
                    L_ij[A, B] = result_mv.components[A]

            L[(i, j)] = L_ij

    return L


def analyze_generators(L):
    """Analyze properties of the bivector generators."""
    info = {}

    for (i, j), Lij in L.items():
        # Check antisymmetry: L should be antisymmetric in the G inner product
        # G L + L^T G = 0 (antisymmetric under G metric)
        is_real = np.allclose(Lij.imag, 0) if np.iscomplexobj(Lij) else True

        # Grade structure
        grade_shifts = set()
        for A in range(N_COMPONENTS):
            gA = basis_grade(A)
            for B in range(N_COMPONENTS):
                if abs(Lij[A, B]) > 1e-10:
                    gB = basis_grade(B)
                    grade_shifts.add(gB - gA)

        # Eigenvalues
        evals = np.linalg.eigvals(Lij)
        # Should be purely imaginary (rotation generators are antisymmetric)
        max_real = np.max(np.abs(np.real(evals)))
        max_imag = np.max(np.abs(np.imag(evals)))

        info[(i, j)] = {
            'grade_shifts': sorted(grade_shifts),
            'rank': np.linalg.matrix_rank(Lij, tol=1e-10),
            'max_real_eval': max_real,
            'max_imag_eval': max_imag,
        }

    return info


# =============================================================================
# PHASE 2: SO(3)_space × SO(3)_time DECOMPOSITION
# =============================================================================

def build_casimir_operators(L):
    """Build Casimir operators for SO(3)_space and SO(3)_time.

    SO(3)_space generators: J₁ = L_{12}, J₂ = L_{20}, J₃ = L_{01}
    SO(3)_time generators:  K₁ = L_{45}, K₂ = L_{53}, K₃ = L_{34}

    Casimir: J² = J₁² + J₂² + J₃², K² = K₁² + K₂² + K₃²

    Cross generators (boosts): L_{03}, L_{04}, L_{05}, L_{13}, L_{14}, L_{15},
                                L_{23}, L_{24}, L_{25}
    """
    # Spacelike angular momentum SO(3) of e₀, e₁, e₂
    # Convention: J₁ = L_{12}, J₂ = L_{02}, J₃ = L_{01}
    # Verified: [L_{12}, L_{02}] = L_{01}, [L_{02}, L_{01}] = L_{12}, etc.
    J = np.zeros((3, N_COMPONENTS, N_COMPONENTS))
    J[0] = L[(1, 2)]  # J₁ = L_{12}
    J[1] = L[(0, 2)]  # J₂ = L_{02}
    J[2] = L[(0, 1)]  # J₃ = L_{01}

    # Timelike angular momentum SO(3) of e₃, e₄, e₅
    K = np.zeros((3, N_COMPONENTS, N_COMPONENTS))
    K[0] = L[(4, 5)]   # K₁ = L_{45}
    K[1] = L[(3, 5)]   # K₂ = L_{35}
    K[2] = L[(3, 4)]   # K₃ = L_{34}

    # Casimir operators
    J_sq = J[0] @ J[0] + J[1] @ J[1] + J[2] @ J[2]
    K_sq = K[0] @ K[0] + K[1] @ K[1] + K[2] @ K[2]

    # Cross (boost) generators
    boost_generators = []
    for i in range(3):  # spatial
        for j in range(3, 6):  # temporal
            boost_generators.append(L[(i, j)])

    B_sq = sum(B @ B for B in boost_generators)

    # Total angular Casimir (SO(6) Casimir = J² + K² + B²)
    # Actually SO(3,3) Casimir — need to be careful with signs
    total_sq = J_sq + K_sq + B_sq

    return J, K, J_sq, K_sq, B_sq, total_sq


def decompose_angular_sectors(J_sq, K_sq, total_sq, G):
    """Decompose the 64-dim space into irreps of SO(3)_space × SO(3)_time.

    Simultaneously diagonalize J², K², and the total Casimir.
    The eigenvalues are j_s(j_s+1), j_t(j_t+1), and ℓ_total.
    """
    # J² and K² should commute (they act on independent subspaces)
    comm_JK = J_sq @ K_sq - K_sq @ J_sq
    comm_norm = np.max(np.abs(comm_JK))

    # Try to simultaneously diagonalize J² and K²
    # Since [J², K²] ≈ 0, we can diagonalize J² first, then K² within each eigenspace

    evals_J, evecs_J = eigh(J_sq)  # J² is real symmetric
    evals_K, evecs_K = eigh(K_sq)
    evals_tot, evecs_tot = eigh(total_sq)

    return {
        'comm_JK_norm': comm_norm,
        'J_sq_evals': evals_J,
        'K_sq_evals': evals_K,
        'total_sq_evals': evals_tot,
        'J_sq_evecs': evecs_J,
    }


# =============================================================================
# PHASE 3: Angular Casimir eigenvalues → effective angular quantum numbers
# =============================================================================

def identify_angular_sectors(J_sq, K_sq, total_sq):
    """Find the simultaneous eigenspaces of J² and K².

    For each eigenspace, determine the quantum numbers (j_s, j_t)
    and the effective angular eigenvalue for the radial problem.
    """
    # First diagonalize J²
    evals_J, evecs_J = eigh(J_sq)

    # Round eigenvalues to j(j+1) for half-integer j
    j_values = []
    for ev in evals_J:
        # Solve j(j+1) = ev → j = (-1 + sqrt(1 + 4*ev)) / 2
        if ev < -0.01:
            j_values.append(-1)
        else:
            j = (-1 + np.sqrt(max(0, 1 + 4 * ev))) / 2
            j_values.append(round(2 * j) / 2)  # Round to nearest half-integer

    # Group basis vectors by j_s eigenvalue
    sectors = {}
    for idx in range(N_COMPONENTS):
        j_s = j_values[idx]
        if j_s not in sectors:
            sectors[j_s] = []
        sectors[j_s].append(idx)

    # Within each j_s sector, diagonalize K² in the transformed basis
    V = evecs_J  # V diagonalizes J²
    K_sq_rot = V.T @ K_sq @ V

    # Check K² eigenvalues within each j_s sector
    sector_info = {}
    for j_s, indices in sorted(sectors.items()):
        # Extract the K² subblock for this j_s sector
        n = len(indices)
        K_sub = K_sq_rot[np.ix_(indices, indices)]
        evals_K_sub = np.linalg.eigvalsh(K_sub)

        # Identify j_t values
        j_t_values = []
        for ev in evals_K_sub:
            if ev < -0.01:
                j_t_values.append(-1)
            else:
                j_t = (-1 + np.sqrt(max(0, 1 + 4 * ev))) / 2
                j_t_values.append(round(2 * j_t) / 2)

        # Also get total Casimir in this sector
        tot_sub = evecs_J[:, indices].T @ total_sq @ evecs_J[:, indices]
        evals_tot_sub = np.linalg.eigvalsh(tot_sub)

        sector_info[j_s] = {
            'count': n,
            'K_evals': evals_K_sub,
            'j_t_values': sorted(set(j_t_values)),
            'total_evals': evals_tot_sub,
        }

    return sector_info


# =============================================================================
# PHASE 4: Radial eigenvalue problem with angular Casimir
# =============================================================================

def solve_radial_with_casimir(angular_ev, N=2000, r_max=3.0):
    """Solve -u'' + [angular_ev/r² + V''(ρ₀(r))] u = λ u."""
    dr = r_max / (N + 1)
    r = np.linspace(dr, r_max - dr, N)

    rho = np.where(r <= a, rho_0 * (1.0 - (r / a) ** 2), 0.0)
    mu_sq = 2.0 * lam * rho_0 ** 2
    V_dd = -2.0 * mu_sq + 12.0 * lam * rho ** 2

    V_eff = angular_ev / r ** 2 + V_dd

    diag = 2.0 / dr ** 2 + V_eff
    offdiag = np.full(N - 1, -1.0 / dr ** 2)

    evals = eigh_tridiagonal(diag, offdiag, eigvals_only=True,
                              select='i', select_range=(0, 2))
    return evals


# =============================================================================
# MAIN
# =============================================================================

def main():
    W = 78
    ratio_target = beta ** 2 / (4 * np.pi ** 2)

    print()
    print("=" * W)
    print("  HESSIAN v7: Rotor-Based Angular Decomposition")
    print("=" * W)
    print(f"  β = {beta:.10f}")
    print(f"  Target ratio σ/β = β²/(4π²) = {ratio_target:.6f}")

    # ===== Compute bivector generators =====
    print(f"\n{'PHASE 1: BIVECTOR GENERATORS L_ij':^{W}}")
    print("-" * W)

    L = compute_bivector_generators()
    gen_info = analyze_generators(L)

    print(f"  15 bivector generators computed (6 choose 2 = 15)")
    print(f"\n  {'(i,j)':>6s} {'rank':>5s} {'grade shifts':>20s} "
          f"{'max Re(λ)':>12s} {'max Im(λ)':>12s}")

    # Group by type
    spatial_pairs = [(0, 1), (0, 2), (1, 2)]
    temporal_pairs = [(3, 4), (3, 5), (4, 5)]
    boost_pairs = [(i, j) for i in range(3) for j in range(3, 6)]

    for label, pairs in [("Spatial SO(3)", spatial_pairs),
                          ("Temporal SO(3)", temporal_pairs),
                          ("Boosts", boost_pairs[:3])]:
        print(f"\n  {label}:")
        for (i, j) in pairs:
            info = gen_info[(i, j)]
            print(f"  L_{i}{j}    {info['rank']:5d} "
                  f"{str(info['grade_shifts']):>20s} "
                  f"{info['max_real_eval']:12.4e} "
                  f"{info['max_imag_eval']:12.4f}")

    # ===== Check commutation relations =====
    print(f"\n{'PHASE 1b: COMMUTATION RELATIONS':^{W}}")
    print("-" * W)

    # [J_i, J_j] = ε_ijk J_k (SO(3) algebra)
    # With our assignment: J₁ = L_{12}, J₂ = -L_{02}, J₃ = L_{01}
    J1, J2, J3 = L[(1, 2)], L[(0, 2)], L[(0, 1)]

    comm_12 = J1 @ J2 - J2 @ J1
    err_J = np.max(np.abs(comm_12 - J3))
    print(f"  [J₁, J₂] = J₃: error = {err_J:.2e}")

    comm_23 = J2 @ J3 - J3 @ J2
    err_J2 = np.max(np.abs(comm_23 - J1))
    print(f"  [J₂, J₃] = J₁: error = {err_J2:.2e}")

    comm_31 = J3 @ J1 - J1 @ J3
    err_J3 = np.max(np.abs(comm_31 - J2))
    print(f"  [J₃, J₁] = J₂: error = {err_J3:.2e}")

    # Same for K
    K1, K2, K3 = L[(4, 5)], L[(3, 5)], L[(3, 4)]

    comm_K12 = K1 @ K2 - K2 @ K1
    err_K = np.max(np.abs(comm_K12 - K3))
    print(f"  [K₁, K₂] = K₃: error = {err_K:.2e}")

    # [J, K] should be zero (independent subgroups)
    comm_JK = J1 @ K1 - K1 @ J1
    err_JK = np.max(np.abs(comm_JK))
    print(f"  [J₁, K₁] = 0:  error = {err_JK:.2e}")

    # ===== Build Casimir operators =====
    print(f"\n{'PHASE 2: CASIMIR OPERATORS':^{W}}")
    print("-" * W)

    J = np.array([J1, J2, J3])
    K = np.array([K1, K2, K3])

    J_sq = J1 @ J1 + J2 @ J2 + J3 @ J3
    K_sq = K1 @ K1 + K2 @ K2 + K3 @ K3

    # Boost Casimir
    B_sq = np.zeros((N_COMPONENTS, N_COMPONENTS))
    for i in range(3):
        for j in range(3, 6):
            Lij = L[(i, j)]
            B_sq += Lij @ Lij

    total_sq = J_sq + K_sq + B_sq

    # Eigenvalues of J²
    evals_J = np.linalg.eigvalsh(J_sq)
    evals_K = np.linalg.eigvalsh(K_sq)
    evals_B = np.linalg.eigvalsh(B_sq)
    evals_tot = np.linalg.eigvalsh(total_sq)

    # Identify j values from j(j+1)
    def identify_j(ev):
        if ev < -0.01:
            return -1
        j = (-1 + np.sqrt(max(0, 1 + 4 * abs(ev)))) / 2
        return round(2 * j) / 2

    print(f"\n  J² eigenvalue spectrum (SO(3)_space):")
    unique_J = sorted(set(round(ev, 4) for ev in evals_J))
    for ev in unique_J:
        count = sum(1 for e in evals_J if abs(e - ev) < 0.01)
        j = identify_j(ev)
        print(f"    j_s = {j:.1f} (j(j+1) = {ev:8.4f}): "
              f"degeneracy = {count}")

    print(f"\n  K² eigenvalue spectrum (SO(3)_time):")
    unique_K = sorted(set(round(ev, 4) for ev in evals_K))
    for ev in unique_K:
        count = sum(1 for e in evals_K if abs(e - ev) < 0.01)
        j = identify_j(ev)
        print(f"    j_t = {j:.1f} (j(j+1) = {ev:8.4f}): "
              f"degeneracy = {count}")

    print(f"\n  Total Casimir L² eigenvalue spectrum:")
    unique_tot = sorted(set(round(ev, 4) for ev in evals_tot))
    for ev in unique_tot:
        count = sum(1 for e in evals_tot if abs(e - ev) < 0.01)
        # For SO(6): eigenvalue is ℓ(ℓ+4) for symmetric traceless tensors
        # Check if ev = ℓ(ℓ+4) for some integer ℓ
        disc = 4 + ev
        if disc >= 0:
            ell = (-4 + np.sqrt(16 + 4 * ev)) / 2
        else:
            ell = -1
        print(f"    L² = {ev:8.4f} (ℓ ≈ {ell:.2f}): "
              f"degeneracy = {count}")

    # ===== Phase 3: Simultaneous decomposition =====
    print(f"\n{'PHASE 3: SIMULTANEOUS (j_s, j_t) DECOMPOSITION':^{W}}")
    print("-" * W)

    # Simultaneously diagonalize J² and K²
    # Check if they commute
    comm = J_sq @ K_sq - K_sq @ J_sq
    print(f"  [J², K²] norm = {np.max(np.abs(comm)):.2e}")

    # Build the combined matrix J² + α K² with irrational α to break degeneracies
    alpha_break = np.pi  # Irrational mixing coefficient
    combined = J_sq + alpha_break * K_sq
    evals_comb, evecs_comb = eigh(combined)

    # For each eigenvector, compute j_s and j_t
    sectors = {}
    for idx in range(N_COMPONENTS):
        v = evecs_comb[:, idx]
        js_val = v @ J_sq @ v
        jt_val = v @ K_sq @ v
        b_val = v @ B_sq @ v
        tot_val = v @ total_sq @ v

        js = identify_j(js_val)
        jt = identify_j(jt_val)

        # Grade content
        grade_content = {}
        for A in range(N_COMPONENTS):
            g = basis_grade(A)
            if g not in grade_content:
                grade_content[g] = 0.0
            grade_content[g] += v[A] ** 2
        dominant_grade = max(grade_content, key=grade_content.get)

        key = (js, jt)
        if key not in sectors:
            sectors[key] = {
                'count': 0,
                'boost_vals': [],
                'total_vals': [],
                'grades': [],
            }
        sectors[key]['count'] += 1
        sectors[key]['boost_vals'].append(b_val)
        sectors[key]['total_vals'].append(tot_val)
        sectors[key]['grades'].append(dominant_grade)

    print(f"\n  {'(j_s, j_t)':>12s} {'count':>6s} {'B² range':>20s} "
          f"{'L² range':>20s} {'grades':>15s}")
    for (js, jt) in sorted(sectors.keys()):
        s = sectors[(js, jt)]
        b_min = min(s['boost_vals'])
        b_max = max(s['boost_vals'])
        t_min = min(s['total_vals'])
        t_max = max(s['total_vals'])
        grades = sorted(set(s['grades']))
        print(f"  ({js:.1f}, {jt:.1f})    {s['count']:6d} "
              f"[{b_min:8.3f}, {b_max:8.3f}] "
              f"[{t_min:8.3f}, {t_max:8.3f}] {grades}")

    # ===== Phase 4: Effective angular eigenvalues =====
    print(f"\n{'PHASE 4: EFFECTIVE ANGULAR EIGENVALUES':^{W}}")
    print("-" * W)

    # The angular Casimir L² gives the effective centrifugal term
    # For each sector (j_s, j_t), the radial equation is:
    #   -u'' + [L²_eff / r² + V''(ρ₀)] u = λ u
    # where L²_eff is the total Casimir eigenvalue

    print(f"\n  Using total Casimir L² as effective angular eigenvalue:")
    print(f"\n  {'Sector':>12s} {'L²_eff':>10s} {'λ₀':>12s} {'ratio':>12s} "
          f"{'dev':>8s}")
    print(f"  {'-'*12} {'-'*10} {'-'*12} {'-'*12} {'-'*8}")

    # Compression reference: (j_s, j_t) = (0, 0) sector
    comp_total = None
    for (js, jt) in sorted(sectors.keys()):
        if abs(js) < 0.01 and abs(jt) < 0.01:
            comp_total = np.mean(sectors[(js, jt)]['total_vals'])
            break

    if comp_total is None:
        # Use smallest total Casimir as compression
        all_totals = [(np.mean(s['total_vals']), js, jt)
                      for (js, jt), s in sectors.items()]
        all_totals.sort()
        comp_total = all_totals[0][0]

    # Solve radial for compression
    ev_comp = solve_radial_with_casimir(max(0, comp_total))

    for (js, jt) in sorted(sectors.keys()):
        s = sectors[(js, jt)]
        L2_eff = np.mean(s['total_vals'])

        if L2_eff < -0.01:
            # Negative angular eigenvalue — bound state may not exist
            print(f"  ({js:.1f}, {jt:.1f}) {L2_eff:10.4f}   "
                  f"(negative — tachyonic angular sector)")
            continue

        ev = solve_radial_with_casimir(L2_eff)
        ratio = ev[0] / ev_comp[0] if ev_comp[0] != 0 else float('nan')
        dev = abs(ratio / ratio_target - 1) * 100
        marker = " ***" if dev < 10 else ""
        print(f"  ({js:.1f}, {jt:.1f}) {L2_eff:10.4f} {ev[0]:12.4f} "
              f"{ratio:12.6f} {dev:7.1f}%{marker}")

    # ===== Phase 5: Fine scan of angular eigenvalues =====
    print(f"\n{'PHASE 5: FINE SCAN — WHAT L² GIVES THE TARGET?':^{W}}")
    print("-" * W)

    # Find the exact L²_eff that gives ratio = target
    from scipy.optimize import brentq

    def ratio_minus_target(L2_eff):
        ev = solve_radial_with_casimir(L2_eff)
        return ev[0] / ev_comp[0] - ratio_target

    # Search in range [0, 50]
    try:
        L2_exact = brentq(ratio_minus_target, 0.1, 50.0)
        ev_exact = solve_radial_with_casimir(L2_exact)
        print(f"  Exact L²_eff for target ratio: {L2_exact:.6f}")
        print(f"  Corresponding λ₀: {ev_exact[0]:.6f}")
        print(f"  Compression λ₀: {ev_comp[0]:.6f}")
        print(f"  Ratio: {ev_exact[0] / ev_comp[0]:.6f}")

        # What angular quantum number does this correspond to?
        # For standard S⁵: ℓ(ℓ+4) + 15/4 = L2_exact → ℓ = (-4 + √(16+4(L2-15/4)))/2
        L2_orbital = L2_exact - 15.0 / 4  # Subtract self-adjoint correction
        disc = 16 + 4 * L2_orbital
        if disc >= 0:
            ell_eff = (-4 + np.sqrt(disc)) / 2
        else:
            ell_eff = -1
        print(f"  Effective ℓ (if scalar): {ell_eff:.6f}")

        # For Dirac: (ℓ+3)² = L2_exact → ℓ = √L2_exact - 3
        ell_dirac = np.sqrt(L2_exact) - 3
        print(f"  Effective ℓ (if Dirac): {ell_dirac:.6f}")

        # Check: is L2_exact = j_s(j_s+1) + j_t(j_t+1) + boost?
        # Or more specifically, can it arise from the SO(3)×SO(3) decomposition?
        print(f"\n  Checking if L²={L2_exact:.4f} matches any Casimir sector:")
        for (js, jt) in sorted(sectors.keys()):
            s = sectors[(js, jt)]
            L2_sector = np.mean(s['total_vals'])
            diff = abs(L2_sector - L2_exact)
            if diff < 1.0:
                print(f"    ({js:.1f}, {jt:.1f}): L²={L2_sector:.4f}, "
                      f"diff={diff:.4f}")

        # Also try j_s(j_s+1) + j_t(j_t+1) for various j values
        print(f"\n  Pure rotation sectors j_s(j_s+1) + j_t(j_t+1):")
        for js in [0, 0.5, 1, 1.5, 2, 2.5, 3]:
            for jt in [0, 0.5, 1, 1.5, 2, 2.5, 3]:
                L2_pure = js * (js + 1) + jt * (jt + 1)
                diff = abs(L2_pure - L2_exact)
                if diff < 0.5:
                    print(f"    j_s={js:.1f}, j_t={jt:.1f}: "
                          f"j_s(j_s+1)+j_t(j_t+1) = {L2_pure:.4f}, "
                          f"diff = {diff:.4f}")

    except ValueError:
        print(f"  No L²_eff in [0.1, 50] gives the target ratio.")

    # ===== Summary =====
    print(f"\n{'=' * W}")
    print(f"  SUMMARY: ROTOR ANGULAR DECOMPOSITION")
    print(f"{'=' * W}")
    print(f"\n  The 64-dim multivector space decomposes under SO(3)×SO(3):")
    for (js, jt) in sorted(sectors.keys()):
        s = sectors[(js, jt)]
        L2_eff = np.mean(s['total_vals'])
        print(f"    ({js:.1f}, {jt:.1f}): {s['count']} modes, "
              f"L²_eff = {L2_eff:.4f}, grades = {sorted(set(s['grades']))}")

    print(f"\n  Target: β²/(4π²) = {ratio_target:.6f}")
    print(f"  Compression reference (lowest sector)")
    print(f"{'=' * W}")


if __name__ == '__main__':
    main()
